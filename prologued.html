<!DOCTYPE html>
<html lang = "en">
<head>
	<meta charset = "utf-8">
	<title>End prologue</title>
	<link rel = 'stylesheet' type = 'text/css' href = 'light.css'>
	<script type="text/javascript" async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML">
	</script>
	<script type="text/x-mathjax-config">
		MathJax.Hub.Config({
		  tex2jax: {inlineMath: [['$','$'], ['\\(','\\)']]}
		});
	</script>	
</head>
<body>

<header>
	<a class = 'nav' href = "chess2.html">Prev</a>
	<span class = 'title'>End prologue</span>
	<a class = 'nav' href = "chess3.html">Next</a>
</header>

<p>
	This extended prologue to a semi-empirical investigation of chess has attempted to develop two points.

</p><ul><li>
	Solving games can require computing trees (like Tic-Tac-Toe), applying simple evaluation functions (like Nim), and a lot of recursive solving of simpler sub-problems (like the Towers of Hanoi).

</li><br><li>
	In the limit, there are physical constraints on computation. In practice these are quite distant from known physical systems that compute, but we can be confident that physical principles shape the characteristics of real things.

</li></ul><p>
	Finally, with a lot of hand-waving, we note that the complexity of chess does not prevent highly performant chess computing. Successful techniques blend some approaches seen in the prologue. A great number of nodes are explored, like brute forcing Tic-Tac-Toe. Evaluations of positions are made with basic arithmetic, like Nim. These evaluations are most often not a basis for perfect induction, but do serve as solutions to sub-problems in the course a full game, the way moving 2 blocks is a sub-problem when solving the Towers of Hanoi. Since 1997, superhuman performance from chess engines has been a reality. Currently, it is readily available on consumer-grade hardware.

</p>
</body>
</html>